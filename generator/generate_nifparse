#!/usr/bin/env ruby

require_relative 'lib/generator'



#File.open "dump.txt", "w" do |outf|
  #PP.pp desc, outf
#end

class CodeGenerator
  def initialize(generated_root)
    @generated_root = generated_root
    @generated_sources = []

    @templates = {}

    FileUtils.mkpath "#{@generated_root}/include"
    FileUtils.mkpath "#{@generated_root}/sources"
  end

  def generate_from_desc_file(file)
    @desc = NIFXML.parse "nifxml/nif.xml"

    @desc.types.each do |type_name, type|
      unless type.kind_of? NIFBasic
        context = TypeContext.new @desc, type

        header = context.template_header
        source = context.template_source

        header_file = "#{@generated_root}/include/#{context.type_file_name}.h"
        source_file = "#{@generated_root}/sources/#{context.type_file_name}.cpp"

        @generated_sources.push header_file, source_file

        File.write header_file, header
        File.write source_file, source

      end
    end


    File.write File.join(@generated_root, "/generated_sources.cmake"), template_generated_sources
  end

end

module TemplateCompiler
  def self.compile_template(name, cclass)
    filename = File.expand_path "../templates/#{name}.erb", __FILE__
    erb = ERB.new File.read filename
    erb.def_method cclass, "template_#{name}", filename
  end
end

class TypeContext
  def initialize(desc, type)
    @desc = desc
    @type = type
    @namespaces, @c_type_name = c_name_for_type_name @type.name
    @required_headers = Set.new
    @required_headers_late = Set.new
    @predefine_types = Set.new
  end

  def header_content
      case @type
      when NIFEnum, NIFBitflags
        template_enum

      when NIFCompound, NIFNiObject
        template_compound_header
      end
  end

  def source_content

  end

  def description_comment(description)
    if !description.nil? && !description.strip.empty?
      "/*!\n" + description.split("\n").map { |line| " * #{line.strip}\n" }.join + " */\n"
    else
      nil
    end
  end

  def header_tag
    "NIFPARSE_GENERATED_#{type_file_name}"
  end

  def type_file_name
    type_name_suitable_for_file_name @type.name
  end

  BAD_NAMES = Set[
    "string"
  ]

  def type_name_suitable_for_file_name(name)
    name = name.gsub /::/, ""
    if BAD_NAMES.include? name
      "ni" + name
    else
      name
    end
  end

  def type_for_field(desc, field)
    type =
      if field.type == "TEMPLATE"
        type = "TEMPLATE"
      else
        typeinfo = @desc.types.fetch field.type
        c_qualified_name_for_type typeinfo
      end

    array_sizes = []

    if field.template_type
      require_type_late field.template_type
      type += "<#{field.template_type}>"
    end

    [ field.arr2, field.arr1 ].each do |array|
      if array
        array_expression = ExpressionParser.new.parse_expression(array).output

        if array_expression.size == 1 && array_expression[0].kind_of?(Numeric)
          @required_headers.add "<array>"
          type = "std::array<#{type}, #{array_expression[0].to_s}>"
          array_sizes.push nil
        else
          @required_headers.add "<vector>"
          type = "std::vector<#{type}>"
          array_sizes.push array_expression
        end
      end
    end

    [ type, array_sizes ]
  end

  def c_name_for_type_name(type_name)
    *namespaces, name = type_name.split "::"
    namespaces.unshift "nifparse"

    return namespaces, name
  end

  def c_qualified_name_for_type(type)
    if type.kind_of? NIFBasic
      type.name
    else
      namespaces, name = c_name_for_type_name type.name

      [ *namespaces, name ].join "::"
    end
  end

  def name_for_field(field)
    name = field.name.gsub(/[\s\?]/, "")
    name << field.suffix if field.suffix
    name
  end

  def require_type(name)
    do_require_type name, @required_headers
  end

  def require_type_late(name)
    do_require_type name, @required_headers_late
  end

  def do_require_type(name, set)
    if name == "TEMPLATE"

    elsif name == "BaseNiObject"
      set.add "<BaseNiObject.h>"

    elsif @desc.types.fetch(name).kind_of? NIFBasic
      set.add "<NIFParseBasicTypes.h>"
    else
      set.add "\"#{type_name_suitable_for_file_name name}.h\""
      if set == @required_headers_late
        @predefine_types.add name
      end
    end
  end
end

TemplateCompiler.compile_template 'header', TypeContext
TemplateCompiler.compile_template 'source', TypeContext
TemplateCompiler.compile_template 'enum', TypeContext
TemplateCompiler.compile_template 'compound_header', TypeContext
TemplateCompiler.compile_template 'generated_sources', CodeGenerator

generator = CodeGenerator.new "generated"
generator.generate_from_desc_file "nifxml/nif.xml"

=begin
generated_root = "generated"

generated_sources = []

desc.types.each do |type_name, type|
  if type.kind_of? NIFBasic
    puts "basic type #{type.name}"
  else
    type_file_name =

    header_file = "#{generated_root}/include/#{type_file_name}.h"
    source_file = "#{generated_root}/sources/#{type_file_name}.cpp"
    generated_sources.push header_file, source_file

    header_io = nil
    source_io = nil
    begin
      header_io = File.open header_file, "w"
      source_io = File.open source_file, "w"

      header_tag =
      header_io.write <<EOF
/*
 * Type description for NIF type #{type_name}
 * Automatically generated by nifparse from nif.xml version #{desc.version}
 * Do not edit manually, all changes will be lost.
 */
#ifndef #{header_tag}
#define #{header_tag}
#pragma once
EOF

      source_io.write <<EOF
/*
 * Type implementation for NIF type #{type_name}
 * Automatically generated by nifparse from nif.xml version #{desc.version}
 * Do not edit manually, all changes will be lost.
 */
#include <#{type_file_name}.h>
EOF



    namespaces.each do |namespace|
      header_io.puts "namespace #{namespace} {"
      source_io.puts "namespace #{namespace} {"
    end

    unless type.description.nil?
      header_io.puts "/*!"

      type.description.split("\n").each do |line|
        header_io.puts " * #{line.strip}"
      end

      header_io.puts " */"
    end

    if type.template
      header_io.puts "template<typename TEMPLATE>"
    end

    case type
    when NIFEnum, NIFBitflags
      suffix = ""

      if type.is_a? NIFBitflags
        suffix = "Values"
      end

      header_io.puts "typedef enum #{type_name}#{suffix}: #{c_qualified_name_for_type desc.types.fetch type.storage} {"

      prefix = ""
      unless type.prefix.nil?
        prefix = "#{type.prefix}_"
      end

      type.options.each do |option|
        unless option.description.nil?
          header_io.puts "  /!*"
          option.description.split("\n").each do |line|
            header_io.puts "   * #{line.strip}"
          end
          header_io.puts "   */"
        end

        header_io.puts "  #{prefix}#{option.name} = #{option.value},"
      end

      header_io.puts "};"

      if type.is_a? NIFBitflags
        header_io.puts "using #{type_name} = Bitflags<#{type_name}#{suffix}>;"
      end

    when NIFCompound, NIFNiObject
      tag =
        if type.is_a? NIFNiObject
          "class"
        else
          "struct"
        end

      header_io.write "#{tag} #{type_name}"

      if type.is_a? NIFNiObject
        header_io.write " : public "

        if type.inherits.nil?
          header_io.write "BaseNiObject"
        else
          header_io.write c_qualified_name_for_type desc.types.fetch type.inherits
        end
      end

      header_io.puts " {"

      type.fields.each do |field|
        unless field.description.nil?
          header_io.puts "  /*!"
          field.description.split("\n").each do |line|
            header_io.puts "   * #{line.strip}"
          end
          header_io.puts "   */"
        end

        type_string, array_expressions = type_for_field desc, field

        header_io.puts "  #{type_string} #{name_for_field field};"
      end


      header_io.puts "};"
    end

    namespaces.each do |namespace|
      header_io.puts "}"
      source_io.puts "}"
    end

    header_io.puts "#endif"

  ensure
    header_io.close unless header_io.nil?
    source_io.close unless source_io.nil?
  end
end

end
=end
